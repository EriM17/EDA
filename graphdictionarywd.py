# -*- coding: utf-8 -*-
"""graph-dictionaryWD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LAeO6qpKKHWzq7uCwT952r-BlIBeztl6

# Graph implementation using a Python dictionary

This implementation allows to represent any kind of graphs.
"""

class AdjacentVertex:
    def __init__(self,vertex,weight):
        self.vertex=vertex
        self.weight=weight
  
    def __str__(self):
        return '('+str(self.vertex)+','+str(self.weight)+')'

class Graph():
    def __init__(self,labels,directed=True):
        self.labels=labels
        self.vertices={}
        for i in range(len(self.labels)):
            self.vertices[i]=[]
        self.directed=directed
    
    def _getIndex(self,v):
        index=-1
        try:
            index=self.labels.index(v)
        except:
            print(v,' is not a vertex!!!')
            pass
        return index 

    def addEdge(self, start, end, weight=0):
        index_start=self._getIndex(start)
        index_end=self._getIndex(end)

        if index_start==-1 or index_end==-1:
            return
        
        if self.containsEdge(start,end)==0:
            self.vertices[index_start].append(AdjacentVertex(index_end,weight))
        if self.directed==False:
            self.vertices[index_end].append(AdjacentVertex(index_start,weight))
      
    def containsEdge(self, start, end):
        index_start=self._getIndex(start)
        index_end=self._getIndex(end)

        if index_start==-1 or index_end==-1:
            return 0
        for adj in self.vertices[index_start]:
            if adj.vertex==index_end:
                return adj.weight
        return 0

    def removeEdge(self,start,end):
        index_start=self._getIndex(start)
        index_end=self._getIndex(end)

        if index_start==-1 or index_end==-1:
            return

        for adj in self.vertices[index_start]:
            if adj.vertex==index_end:
                self.vertices[index_start].remove(adj)
        if self.directed==False:
            for adj in self.vertices[index_end]:
                if adj.vertex==index_start:
                    self.vertices[index_end].remove(adj)
  
    def __str__(self):
        result=''
        for label in self.labels:
            result+='\n'+str(label)+':'
            index=self._getIndex(label)
            for adj in self.vertices[index]:
                result+='('+self.labels[adj.vertex]+','+str(adj.weight)+')'
            
        return result

"""We use the implementation to represent an undirected graph without weights :


<img src='https://computersciencesource.files.wordpress.com/2010/05/dfs_1.png' width='35%'/>
"""

labels=['A','B','C','D','E']
g=Graph(labels,False)
g.addEdge('A','B') # A:0, B:1
g.addEdge('A','C') # A:0, C:2
g.addEdge('A','E') # A:0, E:5
g.addEdge('B','D') # B:1, D:4
g.addEdge('B','E') # C:2, B:1
#g.addEdge('A','H',8)

print(g)

"""Now, we use the implementation to represent this graph: 

<img src='https://upload.wikimedia.org/wikipedia/commons/thumb/b/bc/CPT-Graphs-directed-weighted-ex1.svg/722px-CPT-Graphs-directed-weighted-ex1.svg.png' width='25%'/>
"""

labels=['A','B','C','D','E']

g=Graph(labels)

#Now, we add the edges
g.addEdge('A','C',12) #A->(12)C
g.addEdge('A','D',60) #A->(60)D
g.addEdge('B','A',10) #B->(10)A
g.addEdge('C','B',20) #C->(20)B
g.addEdge('C','D',32) #C->(32)D
g.addEdge('E','A',7)  #E->(7)A

print(g)